# 功能规格说明书：消息异步任务 Future 模式

**Feature**: `message-future`
**Scope**: `packages/async-contracts`
**创建日期**: 2025-12-01
**状态**: Draft
**输入**: 用户描述 "在packages/async-contracts中，参考java.future的功能，在message的基础上实现类似的效果，需要根据系统配置MESSENGER_TRANSPORT_DSN的配置来选择，使用doctrine://就是数据库实现，使用redis://就是redis实现；获取异步执行结果的阻塞等待选择轮询的方式"

## 用户场景与测试（必填）

### 用户故事 1 - 提交异步任务并立即返回（优先级：P1）

开发者在处理耗时操作（如发送邮件、生成报表、调用第三方 API）时，希望将任务提交到后台队列异步执行，并立即获得一个"凭证"对象，用于后续查询任务状态和获取执行结果，而不阻塞当前请求。

**优先级原因**： 这是 Future 模式的核心功能,提供异步提交能力是所有后续操作的前提，直接影响系统的响应性和并发能力。

**独立验证方式**： 开发者调用提交接口传入一个消息对象，立即收到一个 Future 对象（包含任务 ID），验证该调用在毫秒级返回且不阻塞。

**验收场景**：

1. **Given** 系统配置了有效的消息队列传输方式，**When** 开发者提交一个异步任务消息，**Then** 系统立即返回一个 Future 对象，包含唯一的任务 ID
2. **Given** Future 对象已创建，**When** 开发者查询任务状态，**Then** 系统返回当前状态（待执行/执行中/已完成/失败/已取消）
3. **Given** 配置为 doctrine:// 传输方式，**When** 提交任务后查询存储，**Then** 任务信息已保存到数据库
4. **Given** 配置为 redis:// 传输方式，**When** 提交任务后查询存储，**Then** 任务信息已保存到 Redis

---

### 用户故事 2 - 获取异步任务执行结果（优先级：P1）

开发者持有 Future 对象后，需要在任务完成后获取实际的执行结果（成功结果或异常信息），可以选择阻塞等待任务完成（带超时控制），也可以非阻塞轮询检查任务是否完成。

**优先级原因**： 获取结果是 Future 的核心价值，没有结果获取能力则异步任务无法闭环，P1 优先级。

**独立验证方式**： 提交一个简单任务（如返回固定字符串），通过 Future 对象阻塞等待或轮询获取，验证能正确拿到结果或异常。

**验收场景**：

1. **Given** 任务已成功执行完成，**When** 开发者调用 Future 的获取结果方法（阻塞模式，设置超时 30 秒），**Then** 方法返回任务的执行结果
2. **Given** 任务仍在执行中，**When** 开发者调用获取结果方法（超时 5 秒），**Then** 系统通过轮询等待任务完成，最多等待 5 秒后返回结果或抛出超时异常
3. **Given** 任务执行失败并抛出异常，**When** 开发者调用获取结果方法，**Then** 系统抛出原始异常
4. **Given** 任务已完成，**When** 开发者调用非阻塞获取方法，**Then** 立即返回结果（如果未完成则返回 null 或抛出状态异常）

---

### 用户故事 3 - 查询任务状态和取消任务（优先级：P2）

开发者希望能够主动查询任务当前的执行状态（是否完成、是否失败），并且在任务还未执行时能够取消任务。

**优先级原因**： 状态查询提供透明性，取消任务提供控制能力，对于长时间任务管理很重要，但不影响基本功能。

**独立验证方式**： 提交一个延迟执行的任务，查询状态验证返回"待执行"，然后取消任务并验证状态变为"已取消"。

**验收场景**：

1. **Given** 任务刚提交尚未被 Worker 处理，**When** 开发者查询任务状态，**Then** 返回"待执行"状态
2. **Given** 任务正在被 Worker 执行，**When** 开发者查询任务状态，**Then** 返回"执行中"状态
3. **Given** 任务尚未被执行，**When** 开发者调用取消方法，**Then** 任务状态标记为"已取消"且不会被 Worker 执行
4. **Given** 任务已经开始执行或已完成，**When** 开发者调用取消方法，**Then** 返回取消失败（不影响已执行任务）

---

### 用户故事 4 - 根据配置自动适配存储后端（优先级：P2）

系统根据环境变量 `MESSENGER_TRANSPORT_DSN` 的值自动选择任务状态的存储方式，当配置为 `doctrine://...` 时使用数据库持久化，配置为 `redis://...` 时使用 Redis 存储，开发者无需修改代码。

**优先级原因**： 提供灵活性和适配不同部署环境的能力，是架构设计的一部分，不影响核心功能但提升可维护性。

**独立验证方式**： 分别配置两种 DSN，提交任务并验证数据存储位置正确（数据库表或 Redis 键）。

**验收场景**：

1. **Given** 环境变量配置 `MESSENGER_TRANSPORT_DSN=doctrine://default`，**When** 提交任务，**Then** 任务状态和结果存储在数据库表中
2. **Given** 环境变量配置 `MESSENGER_TRANSPORT_DSN=redis://localhost:6379`，**When** 提交任务，**Then** 任务状态和结果存储在 Redis 中
3. **Given** 未配置有效的 DSN，**When** 提交任务，**Then** 系统抛出配置错误异常

---

### 边界/异常场景

- **任务超时**：当阻塞等待超过指定超时时间时，系统应抛出超时异常，不继续等待
- **存储故障**：当数据库或 Redis 不可用时，提交任务或查询状态应返回明确的错误信息
- **任务过期**：已完成的任务结果保留一定时间后自动清理，查询过期任务应返回"任务不存在"错误
- **并发查询**：多个线程/进程同时查询同一任务状态时，应保证数据一致性
- **任务重复执行**：确保同一任务不会被 Worker 重复执行（通过状态锁或幂等性保证）
- **序列化失败**：当任务结果或异常无法序列化时，应保存错误标记并在获取时提示

## 需求（必填）

### 功能需求

- **FR-001**：系统必须提供提交异步任务的接口，接受一个消息对象并立即返回 Future 对象
- **FR-002**：系统必须为每个提交的任务生成全局唯一的任务 ID（如 UUID）
- **FR-003**：系统必须根据 `MESSENGER_TRANSPORT_DSN` 配置自动选择存储后端（数据库或 Redis）
- **FR-004**：系统必须支持查询任务的当前状态（待执行、执行中、已完成、失败、已取消）
- **FR-005**：系统必须提供阻塞方式获取任务结果，支持超时参数（单位：秒）
- **FR-006**：系统必须通过轮询机制实现阻塞等待（默认轮询间隔 100 毫秒）
- **FR-007**：系统必须提供非阻塞方式查询任务结果（立即返回或抛出未完成异常）
- **FR-008**：系统必须在任务执行成功后保存结果数据（序列化存储）
- **FR-009**：系统必须在任务执行失败后保存异常信息（序列化存储）
- **FR-010**：系统必须支持在任务未执行前取消任务
- **FR-011**：系统必须在获取失败任务结果时，重新抛出原始异常
- **FR-012**：系统必须为已完成任务设置默认保留时间（24 小时），过期后自动清理
- **FR-013**：系统必须在数据库模式下创建任务状态表（包含任务 ID、状态、结果、异常、时间戳等字段）
- **FR-014**：系统必须在 Redis 模式下使用键值对存储任务信息（键格式如 `task:{taskId}:status`）
- **FR-015**：系统必须在任务状态变更时更新存储（如从"待执行"更新为"执行中"）

### 核心实体（若涉及数据）

- **异步任务（Task）**：代表一次异步执行的任务，包含任务 ID、状态、提交时间、开始时间、完成时间、结果、异常信息等属性
- **Future 对象**：开发者持有的任务凭证，提供查询状态、获取结果、取消任务等方法，内部持有任务 ID 和存储访问接口
- **任务状态（TaskStatus）**：枚举类型，包含待执行（PENDING）、执行中（RUNNING）、已完成（COMPLETED）、失败（FAILED）、已取消（CANCELLED）五种状态
- **消息对象（Message）**：开发者提交的业务消息，包含业务逻辑所需的数据，需要能够被序列化和反序列化

## 成功标准（必填）

### 可度量结果

- **SC-001**：开发者提交异步任务到返回 Future 对象的耗时不超过 50 毫秒（不包含消息队列传输时间）
- **SC-002**：系统支持每秒至少 1000 次任务提交操作（数据库模式）
- **SC-003**：系统支持每秒至少 5000 次任务提交操作（Redis 模式）
- **SC-004**：任务状态查询操作在 10 毫秒内返回结果（缓存命中场景）
- **SC-005**：阻塞获取结果的轮询开销不超过每秒 10 次轮询（默认 100ms 间隔）
- **SC-006**：90% 的任务能够在提交后 5 秒内被 Worker 开始执行（队列正常情况）
- **SC-007**：已完成任务的结果和异常信息能够 100% 准确保存和恢复
- **SC-008**：在数据库或 Redis 故障时，系统能够返回明确错误信息而不是静默失败

### 定性目标

- 开发者能够在不了解底层存储细节的情况下，通过统一的 Future 接口使用功能
- 代码可在数据库和 Redis 两种模式间切换而无需修改业务逻辑
- 任务执行异常能够被清晰传递给调用方，便于调试和问题定位

## 假设与依赖（必填）

### 假设

- 系统已正确配置 Symfony Messenger 组件，且消息队列传输层正常运行
- 数据库模式下，数据库连接池能够支撑高并发查询
- Redis 模式下，Redis 实例可用且网络延迟低于 5 毫秒
- 任务的序列化和反序列化不会失败（或失败时有明确错误处理）
- Worker 进程会正常消费消息队列并执行任务
- 轮询间隔默认为 100 毫秒，可通过参数调整
- 任务默认保留时间为 24 小时，超时任务会被定时清理机制删除
- 任务 ID 使用 UUID v4，碰撞概率可忽略

### 依赖

- 依赖 Symfony Messenger 组件用于消息分发和消费
- 依赖 Doctrine ORM（数据库模式）或 Redis 客户端库（Redis 模式）
- 依赖 PHP 序列化机制（serialize/unserialize 或 JSON）
- 依赖环境变量 `MESSENGER_TRANSPORT_DSN` 正确配置

## 范围与边界（必填）

### 范围内

- 提供 Future 接口和实现，支持提交任务、查询状态、获取结果、取消任务
- 根据配置自动适配数据库或 Redis 存储后端
- 使用轮询方式实现阻塞等待（带超时控制）
- 任务状态管理和结果持久化
- 异常信息的序列化、保存和恢复
- 任务过期和自动清理机制

### 范围外

- 消息队列的传输实现（由 Symfony Messenger 提供）
- Worker 进程的启动和管理（由部署环境负责）
- 分布式任务调度和负载均衡（由 Messenger 传输层负责）
- 任务执行的监控和告警（需独立的监控系统）
- 实时推送任务完成通知（如 WebSocket、Mercure，本功能仅支持轮询）
- 任务依赖关系管理（如任务 A 完成后才能执行任务 B）
- 批量任务管理（如 CompletableFuture.allOf/anyOf，未来可扩展）

## 非功能需求（选填）

### 性能

- 任务提交响应时间中位数 < 20ms，P99 < 100ms
- 状态查询响应时间中位数 < 5ms，P99 < 50ms
- 数据库模式支持至少 10 万条任务记录的并发查询
- Redis 模式支持至少 100 万条任务记录的并发查询

### 可靠性

- 任务状态和结果的持久化成功率 > 99.9%
- 系统在数据库或 Redis 短暂不可用时能够优雅降级（返回错误而非崩溃）
- Worker 异常终止后，未完成任务能够被重新执行（由 Messenger 重试机制保证）

### 可维护性

- 存储后端切换只需修改环境变量配置，无需代码变更
- 提供清晰的错误日志和异常堆栈信息
- 代码模块化，存储实现和接口分离，便于未来扩展其他存储方式（如 Memcached、文件系统）

### 兼容性

- 支持 PHP 8.1 及以上版本
- 兼容 Symfony 6.x 和 7.x
- 数据库模式支持 MySQL 5.7+、PostgreSQL 12+、SQLite 3.x
- Redis 模式支持 Redis 5.x 及以上

## 未来扩展（选填）

- 支持实时推送通知（通过 Mercure、WebSocket 或 Server-Sent Events）
- 支持批量任务管理（allOf、anyOf、race 等组合操作）
- 支持任务优先级设置和优先级队列
- 支持任务执行进度回调（如 0%-100% 进度更新）
- 支持任务链式依赖（任务 A 完成后自动触发任务 B）
- 提供 Web UI 界面查看任务状态和历史记录
- 支持分布式锁防止任务重复执行（当前依赖 Messenger 机制）

## 参考资料（选填）

- Java Future/CompletableFuture 接口设计
- Symfony Messenger 组件文档
- Doctrine ORM 和 Redis 最佳实践
